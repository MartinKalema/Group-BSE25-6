name: CI/CD Pipeline

on:
  push:
    branches: [staging, production]
  pull_request:
    branches: [staging, production]
  workflow_dispatch:
    inputs:
      environment:
        description: 'Deployment environment'
        required: true
        default: 'staging'
        type: choice
        options:
          - staging
          - production
      action:
        description: 'Action to perform'
        required: true
        default: 'deploy'
        type: choice
        options:
          - deploy
          - rollback

env:
  NODE_VERSION: '20'

jobs:
  install-and-test:
    runs-on: ubuntu-latest
    if: github.event.inputs.action != 'rollback'
    steps:
      - name: Checkout Code
        uses: actions/checkout@v3

      - name: Set up Node.js
        uses: actions/setup-node@v3
        with:
          node-version: ${{ env.NODE_VERSION }}

      - name: Install and Test Backend
        working-directory: backend
        run: |
          npm install
          npm test -- --passWithNoTests

      - name: Install and Test Frontend
        working-directory: frontend
        run: |
          npm install
          npm test -- --passWithNoTests

  build-and-push:
    needs: install-and-test
    runs-on: ubuntu-latest
    if: github.event.inputs.action != 'rollback'
    outputs:
      backend_image: ${{ steps.build_backend.outputs.image }}
      frontend_image: ${{ steps.build_frontend.outputs.image }}
    steps:
      - name: Checkout Code
        uses: actions/checkout@v3

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v1
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ secrets.AWS_REGION }}

      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v1

      - name: Build and push backend image
        id: build_backend
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
          ECR_REPOSITORY: ${{ secrets.ECR_BACKEND_REPOSITORY }}
          IMAGE_TAG: ${{ github.sha }}
        run: |
          docker build -t $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG ./backend
          docker push $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG
          echo "image=$ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG" >> $GITHUB_OUTPUT

      - name: Build and push frontend image
        id: build_frontend
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
          ECR_REPOSITORY: ${{ secrets.ECR_FRONTEND_REPOSITORY }}
          IMAGE_TAG: ${{ github.sha }}
        run: |
          docker build -t $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG ./frontend
          docker push $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG
          echo "image=$ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG" >> $GITHUB_OUTPUT

  deploy:
    needs: build-and-push
    runs-on: ubuntu-latest
    if: github.event.inputs.action != 'rollback'
    environment:
      name: ${{ github.event.inputs.environment || 'staging' }}
    outputs:
      deploy_success: ${{ steps.deploy.outputs.deploy_success }}

    steps:
      - name: Checkout Code
        uses: actions/checkout@v3

      - name: Set up SSH
        env:
          SSH_PRIVATE_KEY: ${{ secrets.SSH_PRIVATE_KEY }}
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.SSH_PRIVATE_KEY }}" > ~/.ssh/id_rsa
          chmod 600 ~/.ssh/id_rsa

      - name: Deploy to EC2
        id: deploy
        env:
          EC2_HOST: ${{ secrets.EC2_STATIC_IP }}
          ECR_BACKEND_REPOSITORY: ${{ secrets.ECR_BACKEND_REPOSITORY }}
          ECR_FRONTEND_REPOSITORY: ${{ secrets.ECR_FRONTEND_REPOSITORY }}
          AWS_REGION: ${{ secrets.AWS_REGION }}
          NAMESPACE: ${{ secrets.NAMESPACE }}
          DEPLOYMENT_BRANCH: ${{ github.event.inputs.environment || 'staging' }}
          BACKEND_IMAGE: ${{ needs.build-and-push.outputs.backend_image }}
          FRONTEND_IMAGE: ${{ needs.build-and-push.outputs.frontend_image }}
          PROJECT_URL: ${{ secrets.PROJECT_URL }}
          DOCKER_SERVER: ${{ secrets.DOCKER_SERVER }}
          AWS_EMAIL: ${{ secrets.AWS_EMAIL }}
          AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        if: success()
        run: |
          ssh -o StrictHostKeyChecking=no -i ~/.ssh/id_rsa ubuntu@$EC2_HOST << 'EOF'

            set -euo pipefail
            
            aws configure set aws_access_key_id "$AWS_ACCESS_KEY_ID"
            aws configure set aws_secret_access_key "$AWS_SECRET_ACCESS_KEY"
            aws configure set region "$AWS_REGION"

            if ! aws sts get-caller-identity &>/dev/null; then
              echo "Error: AWS credentials are not valid or not set correctly"
              exit 1
            fi

            if ! command -v minikube &> /dev/null; then
              echo "Minikube not found, installing..."
              curl -LO https://storage.googleapis.com/minikube/releases/latest/minikube-linux-amd64
              sudo install minikube-linux-amd64 /usr/local/bin/minikube
            fi

            if ! minikube status | grep -q "Running"; then
              minikube start
            fi

            rm -rf deployment

            git clone --branch "$DEPLOYMENT_BRANCH" --depth 1 --filter=blob:none --sparse "$PROJECT_URL" deployment
            cd deployment
            git sparse-checkout set K8s/

            kubectl create namespace "$NAMESPACE" --dry-run=client -o yaml | kubectl apply -f -

            export ECR_PASSWORD=$(aws ecr get-login-password --region $AWS_REGION)

            kubectl create secret docker-registry ecr-secret \
            --docker-server="$DOCKER_SERVER" \
            --docker-username=AWS \
            --docker-password="$ECR_PASSWORD" \
            --docker-email="$AWS_EMAIL" \
            -n "NAMESPACE" \
            --dry-run=client -o yaml | kubectl apply -f -

            kubectl patch serviceaccount default -n "$NAMESPACE" -p '{"imagePullSecrets": [{"name": "ecr-secret"}]}'

            cd K8s
            kubectl apply -f .

            kubectl set image deployment/backend backend="$BACKEND_IMAGE" -n "$NAMESPACE" --record
            kubectl set image deployment/frontend frontend="$FRONTEND_IMAGE" -n "$NAMESPACE" --record

            kubectl annotate deployment/backend kubernetes.io/change-cause="Deployed image $BACKEND_IMAGE" --overwrite -n "$NAMESPACE"
            kubectl annotate deployment/backend previous-image="$BACKEND_IMAGE" --overwrite -n "$NAMESPACE"
            kubectl annotate deployment/frontend kubernetes.io/change-cause="Deployed image $FRONTEND_IMAGE" --overwrite -n "$NAMESPACE"
            kubectl annotate deployment/frontend previous-image="$FRONTEND_IMAGE" --overwrite -n "$NAMESPACE"

            kubectl rollout status deployment/backend -n "$NAMESPACE" --timeout=300s
            kubectl rollout status deployment/frontend -n "$NAMESPACE" --timeout=300s

            pkill -f "kubectl port-forward" || true
            nohup kubectl port-forward svc/frontend -n $NAMESPACE 3000:80 --address 0.0.0.0 > /dev/null 2>&1 &

          EOF
          echo "deploy_success=true" >> $GITHUB_OUTPUT

  rollback:
    runs-on: ubuntu-latest
    if: failure() || github.event.inputs.action == 'rollback'
    environment:
      name: ${{ github.event.inputs.environment || 'staging' }}
    steps:
      - name: Set up SSH
        env:
          SSH_PRIVATE_KEY: ${{ secrets.SSH_PRIVATE_KEY }}
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.SSH_PRIVATE_KEY }}" > ~/.ssh/id_rsa
          chmod 600 ~/.ssh/id_rsa

      - name: Rollback Deployment
        env:
          EC2_HOST: ${{ secrets.EC2_STATIC_IP }}
          NAMESPACE: ${{ secrets.NAMESPACE }}
        run: |
          ssh -o StrictHostKeyChecking=no -i ~/.ssh/id_rsa ubuntu@$EC2_HOST << 'EOF'
            set -euo pipefail

            kubectl rollout undo deployment/backend -n "$NAMESPACE" || { echo "Backend rollback failed"; exit 1; }
            kubectl rollout undo deployment/frontend -n "$NAMESPACE" || { echo "Frontend rollback failed"; exit 1; }

            kubectl rollout status deployment/backend -n "$NAMESPACE" --timeout=300s
            kubectl rollout status deployment/frontend -n "$NAMESPACE" --timeout=300s

            BACKEND_ROLLED_IMAGE=$(kubectl get deployment/backend -n "$NAMESPACE" -o=jsonpath='{.spec.template.spec.containers[0].image}')
            FRONTEND_ROLLED_IMAGE=$(kubectl get deployment/frontend -n "$NAMESPACE" -o=jsonpath='{.spec.template.spec.containers[0].image}')

            echo "Backend rolled back to image: $BACKEND_ROLLED_IMAGE"
            echo "Frontend rolled back to image: $FRONTEND_ROLLED_IMAGE"
          EOF

  cleanup:
    needs: [deploy, rollback]
    runs-on: ubuntu-latest
    if: always()
    steps:
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v1
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ secrets.AWS_REGION }}

      - name: Delete old ECR images
        run: |
          set -euo pipefail

          if ! command -v jq &> /dev/null || ! command -v aws &> /dev/null; then
              echo "Error: jq or aws CLI not found. Please install the required tools."
              exit 1
          fi

          REPOSITORIES=(${{ secrets.ECR_BACKEND_REPOSITORY }} ${{ secrets.ECR_FRONTEND_REPOSITORY }})
          for REPO in "${REPOSITORIES[@]}"
          do
              echo "Cleaning up repository: $REPO"
              IMAGES_TO_DELETE=$(aws ecr list-images --repository-name "$REPO" --query 'imageIds[?type(imageTag)!=`string`].[imageDigest]' --output text | tr '\t' '\n' | sort | head -n -5)
              if [ -n "$IMAGES_TO_DELETE" ]; then
                  if aws ecr batch-delete-image --repository-name "$REPO" --image-ids "$(echo "$IMAGES_TO_DELETE" | jq -R -s -c 'split("\n")[:-1] | map({imageDigest: .})')"; then
                      echo "Successfully deleted old images in $REPO"
                  else
                      echo "Failed to delete images in $REPO"
                      exit 1
                  fi
              else
                  echo "No images to delete in $REPO"
              fi
          done
