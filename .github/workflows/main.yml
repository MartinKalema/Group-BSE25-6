name: CI/CD Pipeline

on:
  push:
    branches: [staging, production]
  pull_request:
    branches: [staging, production]
  workflow_dispatch:
    inputs:
      environment:
        description: 'Deployment environment'
        required: true
        default: 'staging'
        type: choice
        options:
          - staging
          - production
      action:
        description: 'Action to perform'
        required: true
        default: 'deploy'
        type: choice
        options:
          - deploy
          - rollback

env:
  NODE_VERSION: '20'

jobs:
  install-and-test:
    runs-on: ubuntu-latest
    if: github.event.inputs.action != 'rollback'
    steps:
      - name: Checkout Code
        uses: actions/checkout@v3

      - name: Set up Node.js
        uses: actions/setup-node@v3
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'

      - name: Install and Test Backend
        working-directory: backend
        run: |
          npm install
          npm test

      - name: Install and Test Frontend
        working-directory: frontend
        run: |
          npm install
          npm test

  build-and-push:
    needs: install-and-test
    runs-on: ubuntu-latest
    if: github.event.inputs.action != 'rollback'
    outputs:
      backend_image: ${{ steps.build_backend.outputs.image }}
      frontend_image: ${{ steps.build_frontend.outputs.image }}
    steps:
      - name: Checkout Code
        uses: actions/checkout@v3

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v1
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ secrets.AWS_REGION }}

      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v1

      - name: Build and push backend image
        id: build_backend
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
          ECR_REPOSITORY: ${{ secrets.ECR_BACKEND_REPOSITORY }}
          IMAGE_TAG: ${{ github.sha }}
        run: |
          docker build -t $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG ./backend
          docker push $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG
          echo "image=$ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG" >> $GITHUB_OUTPUT

      - name: Build and push frontend image
        id: build_frontend
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
          ECR_REPOSITORY: ${{ secrets.ECR_FRONTEND_REPOSITORY }}
          IMAGE_TAG: ${{ github.sha }}
        run: |
          docker build -t $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG ./frontend
          docker push $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG
          echo "image=$ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG" >> $GITHUB_OUTPUT

  deploy:
    needs: build-and-push
    runs-on: ubuntu-latest
    if: github.event.inputs.action != 'rollback'
    environment:
      name: ${{ github.event.inputs.environment || 'staging' }}
    outputs:
      deploy_success: ${{ steps.deploy.outputs.deploy_success }}

    steps:
      - name: Checkout Code
        uses: actions/checkout@v3

      - name: Set up SSH
        env:
          SSH_PRIVATE_KEY: ${{ secrets.SSH_PRIVATE_KEY }}
        run: |
          mkdir -p ~/.ssh
          echo "$SSH_PRIVATE_KEY" > ~/.ssh/id_rsa
          chmod 600 ~/.ssh/id_rsa
          ssh-keyscan -H ${{ secrets.EC2_STATIC_IP }} >> ~/.ssh/known_hosts

      - name: Deploy to EC2
        id: deploy
        env:
          EC2_HOST: ${{ secrets.EC2_STATIC_IP }}
          ECR_BACKEND_REPOSITORY: ${{ secrets.ECR_BACKEND_REPOSITORY }}
          ECR_FRONTEND_REPOSITORY: ${{ secrets.ECR_FRONTEND_REPOSITORY }}
          AWS_REGION: ${{ secrets.AWS_REGION }}
          NAMESPACE: ${{secrets.NAMESPACE}}
          DEPLOYMENT_BRANCH: ${{ github.event.inputs.environment || 'staging' }}
          BACKEND_IMAGE: ${{ needs.build-and-push.outputs.backend_image }}
          FRONTEND_IMAGE: ${{ needs.build-and-push.outputs.frontend_image }}
          PROJECT_URL: ${{ secrets.PROJECT_URL }}
          DOCKER_SERVER: ${{ secrets.DOCKER_SERVER }}
          AWS_EMAIL: ${{ secrets.AWS_EMAIL }}
        run: |
          ssh ubuntu@$EC2_HOST << EOF
            if ! minikube status | grep -q "Running"; then
              minikube start
            fi

            mkdir -p deployment
            cd deployment
            git init
            git config --global init.defaultBranch $DEPLOYMENT_BRANCH
            git remote get-url origin || git remote add origin $PROJECT_URL
            git config core.sparseCheckout true
            echo "K8s/" > .git/info/sparse-checkout
            git fetch origin $DEPLOYMENT_BRANCH
            git checkout $DEPLOYMENT_BRANCH
            git pull origin $DEPLOYMENT_BRANCH

            aws ecr get-login-password --region $AWS_REGION | docker login --username AWS --password-stdin $DOCKER_SERVER

            kubectl create namespace $NAMESPACE --dry-run=client -o yaml | kubectl apply -f -
            kubectl create secret docker-registry ecr-secret \
              --docker-server=$DOCKER_SERVER \
              --docker-username=AWS \
              --docker-password=$(aws ecr get-login-password --region $AWS_REGION) \
              --docker-email=$AWS_EMAIL \
              -n $NAMESPACE --dry-run=client -o yaml | kubectl apply -f -
            kubectl patch serviceaccount default -n $NAMESPACE -p '{"imagePullSecrets": [{"name": "ecr-secret"}]}'

            kubectl get deployment backend -n $NAMESPACE -o=jsonpath='{.spec.template.spec.containers[0].image}' > /tmp/backend_previous_image
            kubectl get deployment frontend -n $NAMESPACE -o=jsonpath='{.spec.template.spec.containers[0].image}' > /tmp/frontend_previous_image

            cd K8s
            kubectl apply -f namespace.yaml
            kubectl apply -f configmap.yaml
            kubectl apply -f mongo-secrets.yaml
            kubectl apply -f mongodb-deployment.yaml
            kubectl apply -f mongodb-service.yaml
            kubectl apply -f backend-deployment.yaml
            kubectl apply -f backend-service.yaml
            kubectl apply -f frontend-deployment.yaml
            kubectl apply -f frontend-service.yaml

            kubectl set image deployment/backend backend=$BACKEND_IMAGE -n $NAMESPACE
            kubectl set image deployment/frontend frontend=$FRONTEND_IMAGE -n $NAMESPACE

            kubectl rollout status deployment/backend -n $NAMESPACE
            kubectl rollout status deployment/frontend -n $NAMESPACE

            nohup kubectl port-forward svc/frontend -n $NAMESPACE 3000:80 --address 0.0.0.0 > /dev/null 2>&1 &

            echo "$BACKEND_IMAGE" > /tmp/backend_current_image
            echo "$FRONTEND_IMAGE" > /tmp/frontend_current_image
          EOF
          echo "deploy_success=true" >> $GITHUB_OUTPUT

  rollback:
    runs-on: ubuntu-latest
    if: failure() || github.event.inputs.action == 'rollback'
    environment:
      name: ${{ github.event.inputs.environment || 'staging' }}
    steps:
      - name: Set up SSH
        env:
          SSH_PRIVATE_KEY: ${{ secrets.SSH_PRIVATE_KEY }}
        run: |
          mkdir -p ~/.ssh
          echo "$SSH_PRIVATE_KEY" > ~/.ssh/id_rsa
          chmod 600 ~/.ssh/id_rsa
          ssh-keyscan -H ${{ secrets.EC2_STATIC_IP }} >> ~/.ssh/known_hosts

      - name: Rollback Deployment
        env:
          EC2_HOST: ${{ secrets.EC2_STATIC_IP }}
          NAMESPACE: ${{ secrets.NAMESPACE }}
        run: |
          ssh ubuntu@$EC2_HOST << EOF
            BACKEND_PREVIOUS_IMAGE=$(cat /tmp/backend_previous_image)
            FRONTEND_PREVIOUS_IMAGE=$(cat /tmp/frontend_previous_image)

            kubectl set image deployment/backend backend=$BACKEND_PREVIOUS_IMAGE -n $NAMESPACE
            kubectl set image deployment/frontend frontend=$FRONTEND_PREVIOUS_IMAGE -n $NAMESPACE

            kubectl rollout status deployment/backend -n $NAMESPACE
            kubectl rollout status deployment/frontend -n $NAMESPACE

            echo "Rollback completed. Reverted to previous versions:"
            echo "Backend: $BACKEND_PREVIOUS_IMAGE"
            echo "Frontend: $FRONTEND_PREVIOUS_IMAGE"
          EOF

  cleanup:
    needs: [deploy, rollback]
    runs-on: ubuntu-latest
    if: always()
    steps:
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v1
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ secrets.AWS_REGION }}

      - name: Delete old ECR images
        run: |
          REPOSITORIES=(${{ secrets.ECR_BACKEND_REPOSITORY }} ${{ secrets.ECR_FRONTEND_REPOSITORY }})
          for REPO in "${REPOSITORIES[@]}"
          do
            IMAGES_TO_DELETE=$(aws ecr list-images --repository-name "$REPO" --query 'imageIds[?type(imageTag)!=`string`].[imageDigest]' --output text)
            if [ ! -z "$IMAGES_TO_DELETE" ]; then
              aws ecr batch-delete-image --repository-name "$REPO" --image-ids "$IMAGES_TO_DELETE"
            fi
          done
